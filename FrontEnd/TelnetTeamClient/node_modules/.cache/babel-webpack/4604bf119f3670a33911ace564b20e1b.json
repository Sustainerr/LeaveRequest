{"ast":null,"code":"import { Injectable, EventEmitter, NgZone, Optional, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nclass IdleExpiry {\n  constructor() {\n    this.idValue = new Date();\n    this.idlingValue = false;\n  }\n  /*\n   * Gets or sets a unique ID for the window\n   * @param id - The id.\n   * @return The current id.\n   */\n\n\n  id(value) {\n    if (value !== void 0) {\n      if (!value) {\n        throw new Error('A value must be specified for the ID.');\n      }\n\n      this.idValue = value;\n    }\n\n    return this.idValue;\n  }\n  /*\n   * Gets or sets the idling value.\n   * @param value - The value to set.\n   * @return The idling value.\n   */\n\n\n  idling(value) {\n    if (value !== void 0) {\n      this.idlingValue = value;\n    }\n\n    return this.idlingValue;\n  }\n  /*\n   * Returns the current Date.\n   * @return The current Date.\n   */\n\n\n  now() {\n    /* istanbul ignore next */\n    return new Date();\n  }\n  /*\n   * Returns whether or not it is expired.\n   * @return True if expired; otherwise, false.\n   */\n\n\n  isExpired() {\n    const expiry = this.last();\n    return expiry != null && expiry <= this.now();\n  }\n\n}\n/*\n * A class for managing an interrupt from an interrupt source.\n */\n\n\nclass Interrupt {\n  constructor(source, options) {\n    this.source = source;\n\n    if (source.initialize) {\n      source.initialize(options);\n    }\n  }\n  /*\n   * Subscribes to the interrupt using the specified function.\n   * @param fn - The subscription function.\n   */\n\n\n  subscribe(fn) {\n    this.sub = this.source.onInterrupt.subscribe(fn);\n  }\n  /*\n   * Unsubscribes the interrupt.\n   */\n\n\n  unsubscribe() {\n    this.sub.unsubscribe();\n    this.sub = null;\n  }\n  /*\n   * Keeps the subscription but resumes interrupt events.\n   */\n\n\n  resume() {\n    this.source.attach();\n  }\n  /*\n   * Keeps the subscription but pauses interrupt events.\n   */\n\n\n  pause() {\n    this.source.detach();\n  }\n\n}\n\nclass KeepaliveSvc {}\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\n\n\nclass AlternativeStorage {\n  constructor() {\n    this.storageMap = {};\n  }\n  /*\n   * Returns an integer representing the number of data items stored in the storageMap object.\n   */\n\n\n  get length() {\n    return Object.keys(this.storageMap).length;\n  }\n  /*\n   * Remove all keys out of the storage.\n   */\n\n\n  clear() {\n    this.storageMap = {};\n  }\n  /*\n   * Return the key's value\n   *\n   * @param key - name of the key to retrieve the value of.\n   * @return The key's value\n   */\n\n\n  getItem(key) {\n    if (typeof this.storageMap[key] !== 'undefined') {\n      return this.storageMap[key];\n    }\n\n    return null;\n  }\n  /*\n   * Return the nth key in the storage\n   *\n   * @param index - the number of the key you want to get the name of.\n   * @return The name of the key.\n   */\n\n\n  key(index) {\n    return Object.keys(this.storageMap)[index] || null;\n  }\n  /*\n   * Remove a key from the storage.\n   *\n   * @param key - the name of the key you want to remove.\n   */\n\n\n  removeItem(key) {\n    this.storageMap[key] = undefined;\n  }\n  /*\n   * Add a key to the storage, or update a key's value if it already exists.\n   *\n   * @param key - the name of the key.\n   * @param value - the value you want to give to the key.\n   */\n\n\n  setItem(key, value) {\n    this.storageMap[key] = value;\n  }\n\n}\n/*\n * Represents a localStorage store.\n */\n\n\nlet LocalStorage = /*#__PURE__*/(() => {\n  class LocalStorage {\n    constructor() {\n      this.storage = this.getStorage();\n    }\n    /*\n     * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n     * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n     * setItem\n     * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n     */\n\n\n    getStorage() {\n      try {\n        const storage = localStorage;\n        storage.setItem('ng2IdleStorage', '');\n        storage.removeItem('ng2IdleStorage');\n        return storage;\n      } catch (err) {\n        return new AlternativeStorage();\n      }\n    }\n    /*\n     * Gets an item in the storage.\n     *\n     * @param value - The value to get.\n     * @return The current value.\n     */\n\n\n    getItem(key) {\n      return this.storage.getItem('ng2Idle.' + key);\n    }\n    /*\n     * Removes an item in the storage.\n     *\n     * @param value - The value to remove.\n     */\n\n\n    removeItem(key) {\n      this.storage.removeItem('ng2Idle.' + key);\n    }\n    /*\n     * Sets an item in the storage.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n\n\n    setItem(key, data) {\n      this.storage.setItem('ng2Idle.' + key, data);\n    }\n    /*\n     * Represents the storage, commonly use for testing purposes.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n\n\n    _wrapped() {\n      return this.storage;\n    }\n\n  }\n\n  LocalStorage.ɵfac = function LocalStorage_Factory(t) {\n    return new (t || LocalStorage)();\n  };\n\n  LocalStorage.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LocalStorage,\n    factory: LocalStorage.ɵfac\n  });\n  return LocalStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\n\n\nlet LocalStorageExpiry = /*#__PURE__*/(() => {\n  class LocalStorageExpiry extends IdleExpiry {\n    constructor(localStorage) {\n      super();\n      this.localStorage = localStorage;\n      this.idleName = 'main';\n    }\n    /*\n     * Gets or sets the last expiry date in localStorage.\n     * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n\n\n    last(value) {\n      if (value !== void 0) {\n        this.setExpiry(value);\n      }\n\n      return this.getExpiry();\n    }\n\n    idling(value) {\n      if (value !== void 0) {\n        this.setIdling(value);\n      }\n\n      return this.getIdling();\n    }\n    /*\n     * Gets the idle name.\n     * @return The name of the idle.\n     */\n\n\n    getIdleName() {\n      return this.idleName;\n    }\n    /*\n     * Sets the idle name.\n     * @param The name of the idle.\n     */\n\n\n    setIdleName(key) {\n      if (key) {\n        this.idleName = key;\n      }\n    }\n\n    getExpiry() {\n      const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n\n      if (expiry) {\n        return new Date(parseInt(expiry, 10));\n      } else {\n        return null;\n      }\n    }\n\n    setExpiry(value) {\n      if (value) {\n        this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n      } else {\n        this.localStorage.removeItem(this.idleName + '.expiry');\n      }\n    }\n\n    getIdling() {\n      const idling = this.localStorage.getItem(this.idleName + '.idling');\n\n      if (idling) {\n        return idling === 'true';\n      } else {\n        return false;\n      }\n    }\n\n    setIdling(value) {\n      if (value) {\n        this.localStorage.setItem(this.idleName + '.idling', value.toString());\n      } else {\n        this.localStorage.setItem(this.idleName + '.idling', 'false');\n      }\n    }\n\n  }\n\n  LocalStorageExpiry.ɵfac = function LocalStorageExpiry_Factory(t) {\n    return new (t || LocalStorageExpiry)(ɵngcc0.ɵɵinject(LocalStorage));\n  };\n\n  LocalStorageExpiry.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LocalStorageExpiry,\n    factory: LocalStorageExpiry.ɵfac\n  });\n  return LocalStorageExpiry;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Indicates the desired auto resume behavior.\n */\n\n\nvar AutoResume = /*#__PURE__*/(() => {\n  (function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n  })(AutoResume || (AutoResume = {}));\n\n  return AutoResume;\n})();\n\n/**\n * A service for detecting and responding to user idleness.\n */\nlet Idle = /*#__PURE__*/(() => {\n  class Idle {\n    constructor(expiry, zone, keepaliveSvc, // tslint:disable-next-line: ban-types platform id injection will fail with any other type\n    platformId) {\n      this.expiry = expiry;\n      this.zone = zone;\n      this.platformId = platformId;\n      this.idle = 20 * 60; // in seconds\n\n      this.timeoutVal = 30; // in seconds\n\n      this.autoResume = AutoResume.idle;\n      this.interrupts = new Array();\n      this.running = false;\n      this.keepaliveEnabled = false;\n      this.onIdleStart = new EventEmitter();\n      this.onIdleEnd = new EventEmitter();\n      this.onTimeoutWarning = new EventEmitter();\n      this.onTimeout = new EventEmitter();\n      this.onInterrupt = new EventEmitter();\n\n      if (keepaliveSvc) {\n        this.keepaliveSvc = keepaliveSvc;\n        this.keepaliveEnabled = true;\n      }\n\n      this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n\n\n    setIdleName(key) {\n      if (this.expiry instanceof LocalStorageExpiry) {\n        this.expiry.setIdleName(key);\n      } else {\n        throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n      }\n    }\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n\n\n    getKeepaliveEnabled() {\n      return this.keepaliveEnabled;\n    }\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n\n\n    setKeepaliveEnabled(value) {\n      if (!this.keepaliveSvc) {\n        throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n      }\n\n      return this.keepaliveEnabled = value;\n    }\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n\n\n    getTimeout() {\n      return this.timeoutVal;\n    }\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n\n\n    setTimeout(seconds) {\n      if (seconds === false) {\n        this.timeoutVal = 0;\n      } else if (typeof seconds === 'number' && seconds >= 0) {\n        this.timeoutVal = seconds;\n      } else {\n        throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n      }\n\n      return this.timeoutVal;\n    }\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n\n\n    getIdle() {\n      return this.idle;\n    }\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n\n\n    setIdle(seconds) {\n      if (seconds <= 0) {\n        throw new Error(\"'seconds' must be greater zero\");\n      }\n\n      return this.idle = seconds;\n    }\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n\n\n    getAutoResume() {\n      return this.autoResume;\n    }\n\n    setAutoResume(value) {\n      return this.autoResume = value;\n    }\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n\n\n    setInterrupts(sources) {\n      this.clearInterrupts();\n      const self = this;\n\n      for (const source of sources) {\n        const options = {\n          platformId: this.platformId\n        };\n        const sub = new Interrupt(source, options);\n        sub.subscribe(args => {\n          self.interrupt(args.force, args.innerArgs);\n        });\n        this.interrupts.push(sub);\n      }\n\n      return this.interrupts;\n    }\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n\n\n    getInterrupts() {\n      return this.interrupts;\n    }\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n\n\n    clearInterrupts() {\n      for (const sub of this.interrupts) {\n        sub.pause();\n        sub.unsubscribe();\n      }\n\n      this.interrupts.length = 0;\n    }\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n\n\n    isRunning() {\n      return this.running;\n    }\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n\n\n    isIdling() {\n      return this.idling;\n    }\n    /*\n     * Starts watching for inactivity.\n     */\n\n\n    watch(skipExpiry) {\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n\n      if (!skipExpiry) {\n        const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n        this.expiry.last(value);\n      }\n\n      if (this.idling) {\n        this.toggleState();\n      }\n\n      if (!this.running) {\n        this.startKeepalive();\n        this.toggleInterrupts(true);\n      }\n\n      this.running = true;\n\n      const watchFn = () => {\n        this.zone.run(() => {\n          const diff = this.getExpiryDiff(timeout);\n\n          if (diff > 0) {\n            this.safeClearInterval('idleHandle');\n            this.setIdleIntervalOutsideOfZone(watchFn, diff);\n          } else {\n            this.toggleState();\n          }\n        });\n      };\n\n      this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n    }\n    /*\n     * Allows protractor tests to call waitForAngular without hanging\n     */\n\n\n    setIdleIntervalOutsideOfZone(watchFn, frequency) {\n      this.zone.runOutsideAngular(() => {\n        this.idleHandle = setInterval(watchFn, frequency);\n      });\n    }\n    /*\n     * Stops watching for inactivity.\n     */\n\n\n    stop() {\n      this.stopKeepalive();\n      this.toggleInterrupts(false);\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      this.setIdling(false);\n      this.running = false;\n      this.expiry.last(null);\n    }\n    /*\n     * Forces a timeout event and state.\n     */\n\n\n    timeout() {\n      this.stopKeepalive();\n      this.toggleInterrupts(false);\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      this.setIdling(true);\n      this.running = false;\n      this.countdown = 0;\n      this.onTimeout.emit(null);\n    }\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n\n\n    interrupt(force, eventArgs) {\n      if (!this.running) {\n        return;\n      }\n\n      if (this.timeoutVal && this.expiry.isExpired()) {\n        this.timeout();\n        return;\n      }\n\n      this.onInterrupt.emit(eventArgs);\n\n      if (force === true || this.autoResume === AutoResume.idle || this.autoResume === AutoResume.notIdle && !this.expiry.idling()) {\n        this.watch(force);\n      }\n    }\n\n    setIdling(value) {\n      this.idling = value;\n      this.expiry.idling(value);\n    }\n\n    toggleState() {\n      this.setIdling(!this.idling);\n\n      if (this.idling) {\n        this.onIdleStart.emit(null);\n        this.stopKeepalive();\n\n        if (this.timeoutVal > 0) {\n          this.countdown = this.timeoutVal;\n          this.doCountdown();\n          this.setTimoutIntervalOutsideZone(() => {\n            this.doCountdownInZone();\n          }, 1000);\n        }\n      } else {\n        this.toggleInterrupts(true);\n        this.onIdleEnd.emit(null);\n        this.startKeepalive();\n      }\n\n      this.safeClearInterval('idleHandle');\n    }\n\n    setTimoutIntervalOutsideZone(intervalFn, frequency) {\n      this.zone.runOutsideAngular(() => {\n        this.timeoutHandle = setInterval(() => {\n          intervalFn();\n        }, frequency);\n      });\n    }\n\n    toggleInterrupts(resume) {\n      for (const interrupt of this.interrupts) {\n        if (resume) {\n          interrupt.resume();\n        } else {\n          interrupt.pause();\n        }\n      }\n    }\n\n    getExpiryDiff(timeout) {\n      const now = this.expiry.now();\n      const last = this.expiry.last() || now;\n      return last.getTime() - now.getTime() - timeout * 1000;\n    }\n\n    doCountdownInZone() {\n      this.zone.run(() => {\n        this.doCountdown();\n      });\n    }\n\n    doCountdown() {\n      const diff = this.getExpiryDiff(this.timeoutVal);\n\n      if (diff > 0) {\n        this.safeClearInterval('timeoutHandle');\n        this.interrupt(true);\n        return;\n      }\n\n      if (!this.idling) {\n        return;\n      }\n\n      if (this.countdown <= 0) {\n        this.timeout();\n        return;\n      }\n\n      this.onTimeoutWarning.emit(this.countdown);\n      this.countdown--;\n    }\n\n    safeClearInterval(handleName) {\n      const handle = this[handleName];\n\n      if (handle !== null && typeof handle !== 'undefined') {\n        clearInterval(this[handleName]);\n        this[handleName] = null;\n      }\n    }\n\n    startKeepalive() {\n      if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n        return;\n      }\n\n      if (this.running) {\n        this.keepaliveSvc.ping();\n      }\n\n      this.keepaliveSvc.start();\n    }\n\n    stopKeepalive() {\n      if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n        return;\n      }\n\n      this.keepaliveSvc.stop();\n    }\n    /*\n     * Called by Angular when destroying the instance.\n     */\n\n\n    ngOnDestroy() {\n      this.stop();\n      this.clearInterrupts();\n    }\n\n  }\n\n  Idle.ɵfac = function Idle_Factory(t) {\n    return new (t || Idle)(ɵngcc0.ɵɵinject(IdleExpiry), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(KeepaliveSvc, 8), ɵngcc0.ɵɵinject(PLATFORM_ID, 8));\n  };\n\n  Idle.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Idle,\n    factory: Idle.ɵfac\n  });\n  return Idle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * A class for expressing arguments to interrupt events.\n */\n\n\nclass InterruptArgs {\n  constructor(source, innerArgs, force = false) {\n    this.source = source;\n    this.innerArgs = innerArgs;\n    this.force = force;\n  }\n\n}\n/*\n * A base for classes that act as a source for interrupts.\n */\n\n\nclass InterruptSource {\n  constructor(attachFn, detachFn) {\n    this.attachFn = attachFn;\n    this.detachFn = detachFn;\n    this.isAttached = false;\n    this.onInterrupt = new EventEmitter();\n  }\n  /*\n   * Attaches to the specified events on the specified source.\n   */\n\n\n  attach() {\n    // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n    // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n    // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n    if (Zone.current.get('isAngularZone') === true) {\n      Zone.current.parent.run(() => this.attach());\n      return;\n    }\n\n    if (!this.isAttached && this.attachFn) {\n      this.attachFn(this);\n    }\n\n    this.isAttached = true;\n  }\n  /*\n   * Detaches from the specified events on the specified source.\n   */\n\n\n  detach() {\n    if (this.isAttached && this.detachFn) {\n      this.detachFn(this);\n    }\n\n    this.isAttached = false;\n  }\n\n}\n\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\n\nclass EventTargetInterruptSource extends InterruptSource {\n  constructor(target, events, opts) {\n    super(null, null);\n    this.target = target;\n    this.events = events;\n    this.opts = opts;\n    this.eventSubscription = new Subscription();\n\n    if (typeof this.opts === 'number') {\n      this.opts = {\n        throttleDelay: this.opts,\n        passive: false\n      };\n    }\n\n    this.opts = this.opts || {\n      passive: false,\n      throttleDelay: defaultThrottleDelay\n    };\n\n    if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n      this.opts.throttleDelay = defaultThrottleDelay;\n    }\n\n    this.throttleDelay = this.opts.throttleDelay;\n    this.passive = !!this.opts.passive;\n  }\n\n  initialize(options) {\n    if ((options === null || options === void 0 ? void 0 : options.platformId) && isPlatformServer(options.platformId)) {\n      return;\n    }\n\n    const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n    const opts = this.passive ? {\n      passive: true\n    } : null;\n    const fromEvents = this.events.split(' ').map(eventName => fromEvent(eventTarget, eventName, opts));\n    this.eventSrc = merge(...fromEvents);\n    this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n\n    if (this.throttleDelay > 0) {\n      this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n    }\n\n    const handler = innerArgs => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n\n    this.attachFn = () => this.eventSubscription = this.eventSrc.subscribe(handler);\n\n    this.detachFn = () => this.eventSubscription.unsubscribe();\n  }\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    return false;\n  }\n  /**\n   * Returns the current options being used.\n   * @return The current option values.\n   */\n\n\n  get options() {\n    return {\n      passive: this.passive,\n      throttleDelay: this.throttleDelay\n    };\n  }\n\n}\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\n\n\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => document.documentElement, events, options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    // some browser bad input hacks\n    if (event.type === 'mousemove' && ( // fix for Chrome destop notifications\n    event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0 || // fix for webkit fake mousemove\n    event.movementX !== void 0 && !event.movementX || !event.movementY)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n/*\n * An interrupt source on the Window object.\n */\n\n\nclass WindowInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => window, events, options);\n  }\n\n}\n/*\n * An interrupt source on the storage event of Window.\n */\n\n\nclass StorageInterruptSource extends WindowInterruptSource {\n  constructor(options = 500) {\n    super('storage', options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    if (event.key && event.key.indexOf('ng2Idle.') >= 0 && event.key.indexOf('.expiry') >= 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\n\n\nclass SimpleExpiry extends IdleExpiry {\n  constructor() {\n    super();\n    this.lastValue = null;\n  }\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n\n\n  last(value) {\n    if (value !== void 0) {\n      this.lastValue = value;\n    }\n\n    return this.lastValue;\n  }\n\n}\n\nlet NgIdleModule = /*#__PURE__*/(() => {\n  class NgIdleModule {\n    static forRoot() {\n      return {\n        ngModule: NgIdleModule,\n        providers: [LocalStorageExpiry, {\n          provide: IdleExpiry,\n          useExisting: LocalStorageExpiry\n        }, Idle]\n      };\n    }\n\n  }\n\n  NgIdleModule.ɵfac = function NgIdleModule_Factory(t) {\n    return new (t || NgIdleModule)();\n  };\n\n  NgIdleModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgIdleModule\n  });\n  NgIdleModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [LocalStorage]\n  });\n  return NgIdleModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createDefaultInterruptSources(options) {\n  return [new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options), new StorageInterruptSource(options)];\n}\n\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };","map":{"version":3,"sources":["C:/Users/pprod/Desktop/satge PFE/satge PFE/TelnetTeamClient/node_modules/@ng-idle/core/__ivy_ngcc__/fesm2015/ng-idle-core.js"],"names":["Injectable","EventEmitter","NgZone","Optional","Inject","PLATFORM_ID","NgModule","isPlatformServer","Subscription","fromEvent","merge","filter","throttleTime","ɵngcc0","IdleExpiry","constructor","idValue","Date","idlingValue","id","value","Error","idling","now","isExpired","expiry","last","Interrupt","source","options","initialize","subscribe","fn","sub","onInterrupt","unsubscribe","resume","attach","pause","detach","KeepaliveSvc","AlternativeStorage","storageMap","length","Object","keys","clear","getItem","key","index","removeItem","undefined","setItem","LocalStorage","storage","getStorage","localStorage","err","data","_wrapped","ɵfac","LocalStorage_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","LocalStorageExpiry","idleName","setExpiry","getExpiry","setIdling","getIdling","getIdleName","setIdleName","parseInt","getTime","toString","LocalStorageExpiry_Factory","ɵɵinject","AutoResume","Idle","zone","keepaliveSvc","platformId","idle","timeoutVal","autoResume","interrupts","Array","running","keepaliveEnabled","onIdleStart","onIdleEnd","onTimeoutWarning","onTimeout","getKeepaliveEnabled","setKeepaliveEnabled","getTimeout","setTimeout","seconds","getIdle","setIdle","getAutoResume","setAutoResume","setInterrupts","sources","clearInterrupts","self","args","interrupt","force","innerArgs","push","getInterrupts","isRunning","isIdling","watch","skipExpiry","safeClearInterval","timeout","toggleState","startKeepalive","toggleInterrupts","watchFn","run","diff","getExpiryDiff","setIdleIntervalOutsideOfZone","frequency","runOutsideAngular","idleHandle","setInterval","stop","stopKeepalive","countdown","emit","eventArgs","notIdle","doCountdown","setTimoutIntervalOutsideZone","doCountdownInZone","intervalFn","timeoutHandle","handleName","handle","clearInterval","ping","start","ngOnDestroy","Idle_Factory","InterruptArgs","InterruptSource","attachFn","detachFn","isAttached","Zone","current","get","parent","defaultThrottleDelay","EventTargetInterruptSource","target","events","opts","eventSubscription","throttleDelay","passive","eventTarget","fromEvents","split","map","eventName","eventSrc","pipe","filterEvent","handler","event","DocumentInterruptSource","document","documentElement","type","originalEvent","movementX","movementY","WindowInterruptSource","window","StorageInterruptSource","indexOf","SimpleExpiry","lastValue","NgIdleModule","forRoot","ngModule","providers","provide","useExisting","NgIdleModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","createDefaultInterruptSources","DEFAULT_INTERRUPTSOURCES"],"mappings":"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","sourcesContent":["import { Injectable, EventEmitter, NgZone, Optional, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\nimport * as ɵngcc0 from '@angular/core';\nclass IdleExpiry {\n    constructor() {\n        this.idValue = new Date();\n        this.idlingValue = false;\n    }\n    /*\n     * Gets or sets a unique ID for the window\n     * @param id - The id.\n     * @return The current id.\n     */\n    id(value) {\n        if (value !== void 0) {\n            if (!value) {\n                throw new Error('A value must be specified for the ID.');\n            }\n            this.idValue = value;\n        }\n        return this.idValue;\n    }\n    /*\n     * Gets or sets the idling value.\n     * @param value - The value to set.\n     * @return The idling value.\n     */\n    idling(value) {\n        if (value !== void 0) {\n            this.idlingValue = value;\n        }\n        return this.idlingValue;\n    }\n    /*\n     * Returns the current Date.\n     * @return The current Date.\n     */\n    now() {\n        /* istanbul ignore next */\n        return new Date();\n    }\n    /*\n     * Returns whether or not it is expired.\n     * @return True if expired; otherwise, false.\n     */\n    isExpired() {\n        const expiry = this.last();\n        return expiry != null && expiry <= this.now();\n    }\n}\n\n/*\n * A class for managing an interrupt from an interrupt source.\n */\nclass Interrupt {\n    constructor(source, options) {\n        this.source = source;\n        if (source.initialize) {\n            source.initialize(options);\n        }\n    }\n    /*\n     * Subscribes to the interrupt using the specified function.\n     * @param fn - The subscription function.\n     */\n    subscribe(fn) {\n        this.sub = this.source.onInterrupt.subscribe(fn);\n    }\n    /*\n     * Unsubscribes the interrupt.\n     */\n    unsubscribe() {\n        this.sub.unsubscribe();\n        this.sub = null;\n    }\n    /*\n     * Keeps the subscription but resumes interrupt events.\n     */\n    resume() {\n        this.source.attach();\n    }\n    /*\n     * Keeps the subscription but pauses interrupt events.\n     */\n    pause() {\n        this.source.detach();\n    }\n}\n\nclass KeepaliveSvc {\n}\n\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\nclass AlternativeStorage {\n    constructor() {\n        this.storageMap = {};\n    }\n    /*\n     * Returns an integer representing the number of data items stored in the storageMap object.\n     */\n    get length() {\n        return Object.keys(this.storageMap).length;\n    }\n    /*\n     * Remove all keys out of the storage.\n     */\n    clear() {\n        this.storageMap = {};\n    }\n    /*\n     * Return the key's value\n     *\n     * @param key - name of the key to retrieve the value of.\n     * @return The key's value\n     */\n    getItem(key) {\n        if (typeof this.storageMap[key] !== 'undefined') {\n            return this.storageMap[key];\n        }\n        return null;\n    }\n    /*\n     * Return the nth key in the storage\n     *\n     * @param index - the number of the key you want to get the name of.\n     * @return The name of the key.\n     */\n    key(index) {\n        return Object.keys(this.storageMap)[index] || null;\n    }\n    /*\n     * Remove a key from the storage.\n     *\n     * @param key - the name of the key you want to remove.\n     */\n    removeItem(key) {\n        this.storageMap[key] = undefined;\n    }\n    /*\n     * Add a key to the storage, or update a key's value if it already exists.\n     *\n     * @param key - the name of the key.\n     * @param value - the value you want to give to the key.\n     */\n    setItem(key, value) {\n        this.storageMap[key] = value;\n    }\n}\n\n/*\n * Represents a localStorage store.\n */\nclass LocalStorage {\n    constructor() {\n        this.storage = this.getStorage();\n    }\n    /*\n     * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n     * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n     * setItem\n     * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n     */\n    getStorage() {\n        try {\n            const storage = localStorage;\n            storage.setItem('ng2IdleStorage', '');\n            storage.removeItem('ng2IdleStorage');\n            return storage;\n        }\n        catch (err) {\n            return new AlternativeStorage();\n        }\n    }\n    /*\n     * Gets an item in the storage.\n     *\n     * @param value - The value to get.\n     * @return The current value.\n     */\n    getItem(key) {\n        return this.storage.getItem('ng2Idle.' + key);\n    }\n    /*\n     * Removes an item in the storage.\n     *\n     * @param value - The value to remove.\n     */\n    removeItem(key) {\n        this.storage.removeItem('ng2Idle.' + key);\n    }\n    /*\n     * Sets an item in the storage.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n    setItem(key, data) {\n        this.storage.setItem('ng2Idle.' + key, data);\n    }\n    /*\n     * Represents the storage, commonly use for testing purposes.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n    _wrapped() {\n        return this.storage;\n    }\n}\nLocalStorage.ɵfac = function LocalStorage_Factory(t) { return new (t || LocalStorage)(); };\nLocalStorage.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalStorage, factory: LocalStorage.ɵfac });\nLocalStorage.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorage, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\nclass LocalStorageExpiry extends IdleExpiry {\n    constructor(localStorage) {\n        super();\n        this.localStorage = localStorage;\n        this.idleName = 'main';\n    }\n    /*\n     * Gets or sets the last expiry date in localStorage.\n     * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n    last(value) {\n        if (value !== void 0) {\n            this.setExpiry(value);\n        }\n        return this.getExpiry();\n    }\n    idling(value) {\n        if (value !== void 0) {\n            this.setIdling(value);\n        }\n        return this.getIdling();\n    }\n    /*\n     * Gets the idle name.\n     * @return The name of the idle.\n     */\n    getIdleName() {\n        return this.idleName;\n    }\n    /*\n     * Sets the idle name.\n     * @param The name of the idle.\n     */\n    setIdleName(key) {\n        if (key) {\n            this.idleName = key;\n        }\n    }\n    getExpiry() {\n        const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n        if (expiry) {\n            return new Date(parseInt(expiry, 10));\n        }\n        else {\n            return null;\n        }\n    }\n    setExpiry(value) {\n        if (value) {\n            this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n        }\n        else {\n            this.localStorage.removeItem(this.idleName + '.expiry');\n        }\n    }\n    getIdling() {\n        const idling = this.localStorage.getItem(this.idleName + '.idling');\n        if (idling) {\n            return idling === 'true';\n        }\n        else {\n            return false;\n        }\n    }\n    setIdling(value) {\n        if (value) {\n            this.localStorage.setItem(this.idleName + '.idling', value.toString());\n        }\n        else {\n            this.localStorage.setItem(this.idleName + '.idling', 'false');\n        }\n    }\n}\nLocalStorageExpiry.ɵfac = function LocalStorageExpiry_Factory(t) { return new (t || LocalStorageExpiry)(ɵngcc0.ɵɵinject(LocalStorage)); };\nLocalStorageExpiry.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: LocalStorageExpiry, factory: LocalStorageExpiry.ɵfac });\nLocalStorageExpiry.ctorParameters = () => [\n    { type: LocalStorage }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorageExpiry, [{\n        type: Injectable\n    }], function () { return [{ type: LocalStorage }]; }, null); })();\n\n/*\n * Indicates the desired auto resume behavior.\n */\nvar AutoResume;\n(function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nclass Idle {\n    constructor(expiry, zone, keepaliveSvc, \n    // tslint:disable-next-line: ban-types platform id injection will fail with any other type\n    platformId) {\n        this.expiry = expiry;\n        this.zone = zone;\n        this.platformId = platformId;\n        this.idle = 20 * 60; // in seconds\n        this.timeoutVal = 30; // in seconds\n        this.autoResume = AutoResume.idle;\n        this.interrupts = new Array();\n        this.running = false;\n        this.keepaliveEnabled = false;\n        this.onIdleStart = new EventEmitter();\n        this.onIdleEnd = new EventEmitter();\n        this.onTimeoutWarning = new EventEmitter();\n        this.onTimeout = new EventEmitter();\n        this.onInterrupt = new EventEmitter();\n        if (keepaliveSvc) {\n            this.keepaliveSvc = keepaliveSvc;\n            this.keepaliveEnabled = true;\n        }\n        this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n    setIdleName(key) {\n        if (this.expiry instanceof LocalStorageExpiry) {\n            this.expiry.setIdleName(key);\n        }\n        else {\n            throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n        }\n    }\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n    getKeepaliveEnabled() {\n        return this.keepaliveEnabled;\n    }\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n    setKeepaliveEnabled(value) {\n        if (!this.keepaliveSvc) {\n            throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n        }\n        return (this.keepaliveEnabled = value);\n    }\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n    getTimeout() {\n        return this.timeoutVal;\n    }\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n    setTimeout(seconds) {\n        if (seconds === false) {\n            this.timeoutVal = 0;\n        }\n        else if (typeof seconds === 'number' && seconds >= 0) {\n            this.timeoutVal = seconds;\n        }\n        else {\n            throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n        }\n        return this.timeoutVal;\n    }\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n    getIdle() {\n        return this.idle;\n    }\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n    setIdle(seconds) {\n        if (seconds <= 0) {\n            throw new Error(\"'seconds' must be greater zero\");\n        }\n        return (this.idle = seconds);\n    }\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n    getAutoResume() {\n        return this.autoResume;\n    }\n    setAutoResume(value) {\n        return (this.autoResume = value);\n    }\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n    setInterrupts(sources) {\n        this.clearInterrupts();\n        const self = this;\n        for (const source of sources) {\n            const options = { platformId: this.platformId };\n            const sub = new Interrupt(source, options);\n            sub.subscribe((args) => {\n                self.interrupt(args.force, args.innerArgs);\n            });\n            this.interrupts.push(sub);\n        }\n        return this.interrupts;\n    }\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n    getInterrupts() {\n        return this.interrupts;\n    }\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n    clearInterrupts() {\n        for (const sub of this.interrupts) {\n            sub.pause();\n            sub.unsubscribe();\n        }\n        this.interrupts.length = 0;\n    }\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n    isIdling() {\n        return this.idling;\n    }\n    /*\n     * Starts watching for inactivity.\n     */\n    watch(skipExpiry) {\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n        if (!skipExpiry) {\n            const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n            this.expiry.last(value);\n        }\n        if (this.idling) {\n            this.toggleState();\n        }\n        if (!this.running) {\n            this.startKeepalive();\n            this.toggleInterrupts(true);\n        }\n        this.running = true;\n        const watchFn = () => {\n            this.zone.run(() => {\n                const diff = this.getExpiryDiff(timeout);\n                if (diff > 0) {\n                    this.safeClearInterval('idleHandle');\n                    this.setIdleIntervalOutsideOfZone(watchFn, diff);\n                }\n                else {\n                    this.toggleState();\n                }\n            });\n        };\n        this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n    }\n    /*\n     * Allows protractor tests to call waitForAngular without hanging\n     */\n    setIdleIntervalOutsideOfZone(watchFn, frequency) {\n        this.zone.runOutsideAngular(() => {\n            this.idleHandle = setInterval(watchFn, frequency);\n        });\n    }\n    /*\n     * Stops watching for inactivity.\n     */\n    stop() {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(false);\n        this.running = false;\n        this.expiry.last(null);\n    }\n    /*\n     * Forces a timeout event and state.\n     */\n    timeout() {\n        this.stopKeepalive();\n        this.toggleInterrupts(false);\n        this.safeClearInterval('idleHandle');\n        this.safeClearInterval('timeoutHandle');\n        this.setIdling(true);\n        this.running = false;\n        this.countdown = 0;\n        this.onTimeout.emit(null);\n    }\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n    interrupt(force, eventArgs) {\n        if (!this.running) {\n            return;\n        }\n        if (this.timeoutVal && this.expiry.isExpired()) {\n            this.timeout();\n            return;\n        }\n        this.onInterrupt.emit(eventArgs);\n        if (force === true ||\n            this.autoResume === AutoResume.idle ||\n            (this.autoResume === AutoResume.notIdle && !this.expiry.idling())) {\n            this.watch(force);\n        }\n    }\n    setIdling(value) {\n        this.idling = value;\n        this.expiry.idling(value);\n    }\n    toggleState() {\n        this.setIdling(!this.idling);\n        if (this.idling) {\n            this.onIdleStart.emit(null);\n            this.stopKeepalive();\n            if (this.timeoutVal > 0) {\n                this.countdown = this.timeoutVal;\n                this.doCountdown();\n                this.setTimoutIntervalOutsideZone(() => {\n                    this.doCountdownInZone();\n                }, 1000);\n            }\n        }\n        else {\n            this.toggleInterrupts(true);\n            this.onIdleEnd.emit(null);\n            this.startKeepalive();\n        }\n        this.safeClearInterval('idleHandle');\n    }\n    setTimoutIntervalOutsideZone(intervalFn, frequency) {\n        this.zone.runOutsideAngular(() => {\n            this.timeoutHandle = setInterval(() => {\n                intervalFn();\n            }, frequency);\n        });\n    }\n    toggleInterrupts(resume) {\n        for (const interrupt of this.interrupts) {\n            if (resume) {\n                interrupt.resume();\n            }\n            else {\n                interrupt.pause();\n            }\n        }\n    }\n    getExpiryDiff(timeout) {\n        const now = this.expiry.now();\n        const last = this.expiry.last() || now;\n        return last.getTime() - now.getTime() - timeout * 1000;\n    }\n    doCountdownInZone() {\n        this.zone.run(() => {\n            this.doCountdown();\n        });\n    }\n    doCountdown() {\n        const diff = this.getExpiryDiff(this.timeoutVal);\n        if (diff > 0) {\n            this.safeClearInterval('timeoutHandle');\n            this.interrupt(true);\n            return;\n        }\n        if (!this.idling) {\n            return;\n        }\n        if (this.countdown <= 0) {\n            this.timeout();\n            return;\n        }\n        this.onTimeoutWarning.emit(this.countdown);\n        this.countdown--;\n    }\n    safeClearInterval(handleName) {\n        const handle = this[handleName];\n        if (handle !== null && typeof handle !== 'undefined') {\n            clearInterval(this[handleName]);\n            this[handleName] = null;\n        }\n    }\n    startKeepalive() {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        if (this.running) {\n            this.keepaliveSvc.ping();\n        }\n        this.keepaliveSvc.start();\n    }\n    stopKeepalive() {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        this.keepaliveSvc.stop();\n    }\n    /*\n     * Called by Angular when destroying the instance.\n     */\n    ngOnDestroy() {\n        this.stop();\n        this.clearInterrupts();\n    }\n}\nIdle.ɵfac = function Idle_Factory(t) { return new (t || Idle)(ɵngcc0.ɵɵinject(IdleExpiry), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(KeepaliveSvc, 8), ɵngcc0.ɵɵinject(PLATFORM_ID, 8)); };\nIdle.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Idle, factory: Idle.ɵfac });\nIdle.ctorParameters = () => [\n    { type: IdleExpiry },\n    { type: NgZone },\n    { type: KeepaliveSvc, decorators: [{ type: Optional }] },\n    { type: Object, decorators: [{ type: Optional }, { type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Idle, [{\n        type: Injectable\n    }], function () { return [{ type: IdleExpiry }, { type: ɵngcc0.NgZone }, { type: KeepaliveSvc, decorators: [{\n                type: Optional\n            }] }, { type: Object, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\n\n/*\n * A class for expressing arguments to interrupt events.\n */\nclass InterruptArgs {\n    constructor(source, innerArgs, force = false) {\n        this.source = source;\n        this.innerArgs = innerArgs;\n        this.force = force;\n    }\n}\n\n/*\n * A base for classes that act as a source for interrupts.\n */\nclass InterruptSource {\n    constructor(attachFn, detachFn) {\n        this.attachFn = attachFn;\n        this.detachFn = detachFn;\n        this.isAttached = false;\n        this.onInterrupt = new EventEmitter();\n    }\n    /*\n     * Attaches to the specified events on the specified source.\n     */\n    attach() {\n        // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n        // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n        // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n        if (Zone.current.get('isAngularZone') === true) {\n            Zone.current.parent.run(() => this.attach());\n            return;\n        }\n        if (!this.isAttached && this.attachFn) {\n            this.attachFn(this);\n        }\n        this.isAttached = true;\n    }\n    /*\n     * Detaches from the specified events on the specified source.\n     */\n    detach() {\n        if (this.isAttached && this.detachFn) {\n            this.detachFn(this);\n        }\n        this.isAttached = false;\n    }\n}\n\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nclass EventTargetInterruptSource extends InterruptSource {\n    constructor(target, events, opts) {\n        super(null, null);\n        this.target = target;\n        this.events = events;\n        this.opts = opts;\n        this.eventSubscription = new Subscription();\n        if (typeof this.opts === 'number') {\n            this.opts = { throttleDelay: this.opts, passive: false };\n        }\n        this.opts = this.opts || {\n            passive: false,\n            throttleDelay: defaultThrottleDelay\n        };\n        if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n            this.opts.throttleDelay = defaultThrottleDelay;\n        }\n        this.throttleDelay = this.opts.throttleDelay;\n        this.passive = !!this.opts.passive;\n    }\n    initialize(options) {\n        if ((options === null || options === void 0 ? void 0 : options.platformId) && isPlatformServer(options.platformId)) {\n            return;\n        }\n        const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n        const opts = this.passive ? { passive: true } : null;\n        const fromEvents = this.events\n            .split(' ')\n            .map(eventName => fromEvent(eventTarget, eventName, opts));\n        this.eventSrc = merge(...fromEvents);\n        this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n        if (this.throttleDelay > 0) {\n            this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n        }\n        const handler = (innerArgs) => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n        this.attachFn = () => (this.eventSubscription = this.eventSrc.subscribe(handler));\n        this.detachFn = () => this.eventSubscription.unsubscribe();\n    }\n    /*\n     * Checks to see if the event should be filtered. Always returns false unless overriden.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        return false;\n    }\n    /**\n     * Returns the current options being used.\n     * @return The current option values.\n     */\n    get options() {\n        return {\n            passive: this.passive,\n            throttleDelay: this.throttleDelay\n        };\n    }\n}\n\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n    constructor(events, options) {\n        super(() => document.documentElement, events, options);\n    }\n    /*\n     * Checks to see if the event should be filtered.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        // some browser bad input hacks\n        if (event.type === 'mousemove' &&\n            // fix for Chrome destop notifications\n            ((event.originalEvent &&\n                event.originalEvent.movementX === 0 &&\n                event.originalEvent.movementY === 0) ||\n                // fix for webkit fake mousemove\n                ((event.movementX !== void 0 && !event.movementX) || !event.movementY))) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/*\n * An interrupt source on the Window object.\n */\nclass WindowInterruptSource extends EventTargetInterruptSource {\n    constructor(events, options) {\n        super(() => window, events, options);\n    }\n}\n\n/*\n * An interrupt source on the storage event of Window.\n */\nclass StorageInterruptSource extends WindowInterruptSource {\n    constructor(options = 500) {\n        super('storage', options);\n    }\n    /*\n     * Checks to see if the event should be filtered.\n     * @param event - The original event object.\n     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n     */\n    filterEvent(event) {\n        if (event.key &&\n            event.key.indexOf('ng2Idle.') >= 0 &&\n            event.key.indexOf('.expiry') >= 0) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\nclass SimpleExpiry extends IdleExpiry {\n    constructor() {\n        super();\n        this.lastValue = null;\n    }\n    /*\n     * Gets or sets the last expiry date.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n    last(value) {\n        if (value !== void 0) {\n            this.lastValue = value;\n        }\n        return this.lastValue;\n    }\n}\n\nclass NgIdleModule {\n    static forRoot() {\n        return {\n            ngModule: NgIdleModule,\n            providers: [\n                LocalStorageExpiry,\n                { provide: IdleExpiry, useExisting: LocalStorageExpiry },\n                Idle\n            ]\n        };\n    }\n}\nNgIdleModule.ɵfac = function NgIdleModule_Factory(t) { return new (t || NgIdleModule)(); };\nNgIdleModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgIdleModule });\nNgIdleModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [LocalStorage] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgIdleModule, [{\n        type: NgModule,\n        args: [{\n                providers: [LocalStorage]\n            }]\n    }], null, null); })();\n\nfunction createDefaultInterruptSources(options) {\n    return [\n        new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options),\n        new StorageInterruptSource(options)\n    ];\n}\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };\n\n"]},"metadata":{},"sourceType":"module"}