{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let JwtHelper = /*#__PURE__*/(() => {\n  class JwtHelper {\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n\n        case 2:\n          {\n            output += '==';\n            break;\n          }\n\n        case 3:\n          {\n            output += '=';\n            break;\n          }\n\n        default:\n          {\n            throw new Error('Illegal base64url string!');\n          }\n      }\n\n      return this.b64DecodeUnicode(output);\n    }\n\n    b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(''));\n    }\n\n    b64decode(str) {\n      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n      let output = '';\n      str = String(str).replace(/=+$/, '');\n\n      if (str.length % 4 === 1) {\n        throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n      }\n\n      for ( // initialize result and counters\n      let bc = 0, bs, buffer, idx = 0; // get next character\n      buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n      // tslint:disable-next-line: no-bitwise\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      // tslint:disable-next-line: no-bitwise\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n\n      return output;\n    }\n\n    decodeToken(token) {\n      if (token == null) {\n        token = localStorage.getItem('token');\n      }\n      /**\r\n       * if it is still null, we return null since no token yet\r\n       */\n\n\n      if (token == null) {\n        return null;\n      }\n\n      const parts = token.split('.');\n\n      if (parts.length !== 3) {\n        throw new Error('JWT must have 3 parts');\n      }\n\n      const decoded = this.urlBase64Decode(parts[1]);\n\n      if (!decoded) {\n        throw new Error('Cannot decode the token');\n      }\n\n      return JSON.parse(decoded);\n    }\n\n    getTokenExpirationDate(token) {\n      if (token == null) {\n        token = localStorage.getItem('token');\n      }\n\n      let decoded;\n      decoded = this.decodeToken(token);\n\n      if (!decoded.hasOwnProperty('exp')) {\n        return null;\n      }\n\n      const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n\n    isTokenExpired(token, offsetSeconds) {\n      if (token == null) {\n        token = localStorage.getItem('token');\n      }\n\n      const date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n\n      if (date == null) {\n        return false;\n      } // Token expired?\n\n\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n\n    getTokenUserId(token) {\n      if (token == null) {\n        token = localStorage.getItem('token');\n      }\n\n      let decoded;\n      decoded = this.decodeToken(token);\n\n      if (!decoded.hasOwnProperty('id')) {\n        return null;\n      }\n\n      return decoded.id;\n    }\n\n  }\n\n  JwtHelper.ɵfac = function JwtHelper_Factory(t) {\n    return new (t || JwtHelper)();\n  };\n\n  JwtHelper.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: JwtHelper,\n    factory: JwtHelper.ɵfac\n  });\n  return JwtHelper;\n})();","map":{"version":3,"sources":["C:/Users/pprod/Desktop/satge PFE/satge PFE/TelnetTeamClient/src/app/helpers/jwt-helper.ts"],"names":["i0","JwtHelper","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","decodeURIComponent","Array","prototype","map","call","b64decode","c","charCodeAt","toString","slice","join","chars","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeToken","token","localStorage","getItem","parts","split","decoded","JSON","parse","getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","valueOf","getTokenUserId","id","ɵfac","JwtHelper_Factory","t","ɵprov","ɵɵdefineInjectable","factory"],"mappings":"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","sourcesContent":["import * as i0 from \"@angular/core\";\r\nexport class JwtHelper {\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0: {\r\n                break;\r\n            }\r\n            case 2: {\r\n                output += '==';\r\n                break;\r\n            }\r\n            case 3: {\r\n                output += '=';\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('Illegal base64url string!');\r\n            }\r\n        }\r\n        return this.b64DecodeUnicode(output);\r\n    }\r\n    b64DecodeUnicode(str) {\r\n        return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), (c) => {\r\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n        }).join(''));\r\n    }\r\n    b64decode(str) {\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n        let output = '';\r\n        str = String(str).replace(/=+$/, '');\r\n        if (str.length % 4 === 1) {\r\n            throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\r\n        }\r\n        for (\r\n        // initialize result and counters\r\n        let bc = 0, bs, buffer, idx = 0; \r\n        // get next character\r\n        buffer = str.charAt(idx++); \r\n        // character found in table? initialize bit storage and add its ascii value;\r\n        // tslint:disable-next-line: no-bitwise\r\n        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\r\n            // and if not first of each 4 characters,\r\n            // convert the first 8 bits to one ascii character\r\n            // tslint:disable-next-line: no-bitwise\r\n            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\r\n            // try to find character in table (0-63, not found => -1)\r\n            buffer = chars.indexOf(buffer);\r\n        }\r\n        return output;\r\n    }\r\n    decodeToken(token) {\r\n        if (token == null) {\r\n            token = localStorage.getItem('token');\r\n        }\r\n        /**\r\n         * if it is still null, we return null since no token yet\r\n         */\r\n        if (token == null) {\r\n            return null;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== 3) {\r\n            throw new Error('JWT must have 3 parts');\r\n        }\r\n        const decoded = this.urlBase64Decode(parts[1]);\r\n        if (!decoded) {\r\n            throw new Error('Cannot decode the token');\r\n        }\r\n        return JSON.parse(decoded);\r\n    }\r\n    getTokenExpirationDate(token) {\r\n        if (token == null) {\r\n            token = localStorage.getItem('token');\r\n        }\r\n        let decoded;\r\n        decoded = this.decodeToken(token);\r\n        if (!decoded.hasOwnProperty('exp')) {\r\n            return null;\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(decoded.exp);\r\n        return date;\r\n    }\r\n    isTokenExpired(token, offsetSeconds) {\r\n        if (token == null) {\r\n            token = localStorage.getItem('token');\r\n        }\r\n        const date = this.getTokenExpirationDate(token);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (date == null) {\r\n            return false;\r\n        }\r\n        // Token expired?\r\n        return !(date.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));\r\n    }\r\n    getTokenUserId(token) {\r\n        if (token == null) {\r\n            token = localStorage.getItem('token');\r\n        }\r\n        let decoded;\r\n        decoded = this.decodeToken(token);\r\n        if (!decoded.hasOwnProperty('id')) {\r\n            return null;\r\n        }\r\n        return decoded.id;\r\n    }\r\n}\r\nJwtHelper.ɵfac = function JwtHelper_Factory(t) { return new (t || JwtHelper)(); };\r\nJwtHelper.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: JwtHelper, factory: JwtHelper.ɵfac });\r\n"]},"metadata":{},"sourceType":"module"}